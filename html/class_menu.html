<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Menu Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_menu-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Menu Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries. It shows available functionalities, their corresponding outputs and performance in a clear, organized, and logical manner, facilitating seamless program utilization and straightforward result interpretation.  
 <a href="class_menu.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_menu_8h_source.html">Menu.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad466dd83355124a6ed958430450bfe94" id="r_ad466dd83355124a6ed958430450bfe94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#ad466dd83355124a6ed958430450bfe94">Menu</a> ()</td></tr>
<tr class="memdesc:ad466dd83355124a6ed958430450bfe94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li>Default <a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> constructor - creates a <a class="el" href="class_data.html" title="This class is used to store all the contents from the .csv files into a graph. It will be used by the...">Data</a> object and parse the csv files </li>
</ul>
 <br /></td></tr>
<tr class="separator:ad466dd83355124a6ed958430450bfe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c24dec94e1165caad13b2bb687b2ad" id="r_ab6c24dec94e1165caad13b2bb687b2ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#ab6c24dec94e1165caad13b2bb687b2ad">Menu</a> (<a class="el" href="class_edge.html">string</a> path, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">size</a>)</td></tr>
<tr class="memdesc:ab6c24dec94e1165caad13b2bb687b2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><ul>
<li><a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> constructor - creates a <a class="el" href="class_data.html" title="This class is used to store all the contents from the .csv files into a graph. It will be used by the...">Data</a> object and parse the csv files, based on their path and number of nodes of each graph(size) </li>
</ul>
 <br /></td></tr>
<tr class="separator:ab6c24dec94e1165caad13b2bb687b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae62e1a2096d08d23da4557fef84f8c" id="r_a8ae62e1a2096d08d23da4557fef84f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a8ae62e1a2096d08d23da4557fef84f8c">getGraphMenu</a> ()</td></tr>
<tr class="memdesc:a8ae62e1a2096d08d23da4557fef84f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to get the <a class="el" href="class_graph.html" title="The main class, where the structure used for all the project resides.">Graph</a> object from the <a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> object.  <br /></td></tr>
<tr class="separator:a8ae62e1a2096d08d23da4557fef84f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934fd6cae18c3a4c2072c90af6c7757b" id="r_a934fd6cae18c3a4c2072c90af6c7757b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a934fd6cae18c3a4c2072c90af6c7757b">getCoordinates</a> ()</td></tr>
<tr class="memdesc:a934fd6cae18c3a4c2072c90af6c7757b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to get the coordinates of the nodes as an unordered_map. The temporal complexity is O(1)  <br /></td></tr>
<tr class="separator:a934fd6cae18c3a4c2072c90af6c7757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62025a00de3f3662142b70f21cdfd405" id="r_a62025a00de3f3662142b70f21cdfd405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a62025a00de3f3662142b70f21cdfd405">tspBacktracking</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; g)</td></tr>
<tr class="memdesc:a62025a00de3f3662142b70f21cdfd405"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function performs a backtracking algorithm, in order to find the minimum cost tour of a graph. The temporal complexity is O(V! * V).  <br /></td></tr>
<tr class="separator:a62025a00de3f3662142b70f21cdfd405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cc811b2234509ea0de5f80b86d7a78" id="r_af7cc811b2234509ea0de5f80b86d7a78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#af7cc811b2234509ea0de5f80b86d7a78">tspUtil</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; g, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">current</a>, <a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">currentRoute</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">currentCost</a>, <a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">bestRoute</a>, <a class="el" href="class_edge.html">double</a> &amp;<a class="el" href="class_edge.html">minCost</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">level</a>)</td></tr>
<tr class="memdesc:af7cc811b2234509ea0de5f80b86d7a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">auxiliary function to the backtracking algorithm that is responsible for most of the work by using a dfs search style approach and bounding. The temporal complexity is O(n!)  <br /></td></tr>
<tr class="separator:af7cc811b2234509ea0de5f80b86d7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52be722bbe9d869f93ac174134ee5cf8" id="r_a52be722bbe9d869f93ac174134ee5cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a52be722bbe9d869f93ac174134ee5cf8">triangleApproximationTSP</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;g, <a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt; <a class="el" href="class_edge.html">c</a>)</td></tr>
<tr class="memdesc:a52be722bbe9d869f93ac174134ee5cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function approximates the solution to the Traveling Salesman Problem (TSP) using a triangle inequality heuristic. It has the temporal complexity of O(V^2). This algorithm constructs a Minimum Spanning Tree (MST) of the input graph and then performs a preorder traversal of the MST to create a Hamiltonian circuit. The triangle inequality ensures that the length of the approximated tour is at most twice the length of the optimal tour. If direct distances between vertices are not available, it uses the Haversine formula to compute distances based on geographical coordinates.  <br /></td></tr>
<tr class="separator:a52be722bbe9d869f93ac174134ee5cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fa547b6b61e524bdc16b546ac66d80" id="r_aa1fa547b6b61e524bdc16b546ac66d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#aa1fa547b6b61e524bdc16b546ac66d80">christofides_tsp</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; g, <a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt; <a class="el" href="class_edge.html">c</a>)</td></tr>
<tr class="memdesc:aa1fa547b6b61e524bdc16b546ac66d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function approximates the solution to the Traveling Salesman Problem (TSP) using Christofides' algorithm and improves the solution with a 2-opt optimization. It has the temporal complexity of O(V^3).  <br /></td></tr>
<tr class="separator:aa1fa547b6b61e524bdc16b546ac66d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28dd77536acbbeea5bca4c45b56099b" id="r_ad28dd77536acbbeea5bca4c45b56099b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#ad28dd77536acbbeea5bca4c45b56099b">minimumWeightPerfectMatching</a> (<a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">odd_vertices</a>)</td></tr>
<tr class="memdesc:ad28dd77536acbbeea5bca4c45b56099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds a minimum weight perfect matching for a set of vertices with odd degree. It has the temporal complexity of O(V^3). The function takes a list of vertices with odd degree in the graph and finds a perfect matching where the sum of the weights of the matched edges is minimized. This is an auxiliary function of Christofides' algorithm;.  <br /></td></tr>
<tr class="separator:ad28dd77536acbbeea5bca4c45b56099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0058589ed7a7e18a067c72f18ee615c" id="r_ad0058589ed7a7e18a067c72f18ee615c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#ad0058589ed7a7e18a067c72f18ee615c">eulerianCircuit</a> ()</td></tr>
<tr class="memdesc:ad0058589ed7a7e18a067c72f18ee615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to construct a vector of the Eularian Circuit. It has the temporal complexity of O(VE).  <br /></td></tr>
<tr class="separator:ad0058589ed7a7e18a067c72f18ee615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f796863a9c1778f5382b95682e75d8" id="r_ae3f796863a9c1778f5382b95682e75d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#ae3f796863a9c1778f5382b95682e75d8">heirholzer</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v</a>, <a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">Ecircuit</a>)</td></tr>
<tr class="memdesc:ae3f796863a9c1778f5382b95682e75d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an auxiliary function for the <a class="el" href="class_menu.html#ad0058589ed7a7e18a067c72f18ee615c" title="This function has the purpose to construct a vector of the Eularian Circuit. It has the temporal comp...">eulerianCircuit()</a>. It has the purpose to visit the edges which are also from the MST. It has the temporal complexity of O(VE)  <br /></td></tr>
<tr class="separator:ae3f796863a9c1778f5382b95682e75d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49de2a458af573736812bcc8bdf44b4a" id="r_a49de2a458af573736812bcc8bdf44b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a49de2a458af573736812bcc8bdf44b4a">ConvertToHamiltonianCircuit</a> (<a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">ECircuit</a>)</td></tr>
<tr class="memdesc:a49de2a458af573736812bcc8bdf44b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to convert a Eularian Circuit into an Halmitonian Circuit. It has the complexity of O(V);.  <br /></td></tr>
<tr class="separator:a49de2a458af573736812bcc8bdf44b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6b49afcdd05110a3516efadba215f8" id="r_a7c6b49afcdd05110a3516efadba215f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a7c6b49afcdd05110a3516efadba215f8">CalculateTotalCost</a> (<a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; <a class="el" href="class_edge.html">hamiltonianCircuit</a>, <a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt; <a class="el" href="class_edge.html">c</a>)</td></tr>
<tr class="memdesc:a7c6b49afcdd05110a3516efadba215f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to calculate the cost of the path from the Hamiltonian Circuit. It has the complexity of O(V).  <br /></td></tr>
<tr class="separator:a7c6b49afcdd05110a3516efadba215f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ffbc828e2cc72f42030f8496826075" id="r_a62ffbc828e2cc72f42030f8496826075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a62ffbc828e2cc72f42030f8496826075">haversine</a> (<a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lon1</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lat2</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">lon2</a>)</td></tr>
<tr class="memdesc:a62ffbc828e2cc72f42030f8496826075"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to calculate the distance in meters between two nodes. It has a temporal complexity of O(1);.  <br /></td></tr>
<tr class="separator:a62ffbc828e2cc72f42030f8496826075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120e13899d80994b3fcd38d8111d0ed" id="r_a0120e13899d80994b3fcd38d8111d0ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a0120e13899d80994b3fcd38d8111d0ed">prim</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;g)</td></tr>
<tr class="memdesc:a0120e13899d80994b3fcd38d8111d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prim's algorithm has the purpose to find the Minimum Cost Spanning Tree of a graph. It has a temporal complexity of O(E*log(V)).  <br /></td></tr>
<tr class="separator:a0120e13899d80994b3fcd38d8111d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b53db47b8f918570f23e102d5eae57" id="r_a24b53db47b8f918570f23e102d5eae57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a24b53db47b8f918570f23e102d5eae57">twoOpt2</a> (std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">tour</a>, <a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt; <a class="el" href="class_edge.html">c</a>)</td></tr>
<tr class="memdesc:a24b53db47b8f918570f23e102d5eae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">the purpose of this function is to improve the tour obtained by the christofides algorithm, by performing The temporal complexity is O(N^2), where N is the number of vertices in the tour the swap of two edges a given number of tries until the there are no more improvements or the number of tries if exceeded  <br /></td></tr>
<tr class="separator:a24b53db47b8f918570f23e102d5eae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf46dee4b8249cafbe45f6492f189c" id="r_a5adf46dee4b8249cafbe45f6492f189c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#a5adf46dee4b8249cafbe45f6492f189c">preOrderWalk</a> (<a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; <a class="el" href="class_edge.html">MST</a>)</td></tr>
<tr class="memdesc:a5adf46dee4b8249cafbe45f6492f189c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to iterate over the MST vector resulting from the Prim's algorithm. It has a temporal complexity of 0(VE). It can be compared to the DFS algorithm.  <br /></td></tr>
<tr class="separator:a5adf46dee4b8249cafbe45f6492f189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d6398a62d463a4e4c41f4e4601de51" id="r_af1d6398a62d463a4e4c41f4e4601de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#af1d6398a62d463a4e4c41f4e4601de51">PreOrderWalkDFS</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">node</a>, <a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">result</a>)</td></tr>
<tr class="memdesc:af1d6398a62d463a4e4c41f4e4601de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is auxiliary for the preOrderWalk. It calls itself recursively until it visits all the possible nodes once. It has a temporal complexity of O(E).  <br /></td></tr>
<tr class="separator:af1d6398a62d463a4e4c41f4e4601de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af845794f83083fb6b7275c98423d0e25" id="r_af845794f83083fb6b7275c98423d0e25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#af845794f83083fb6b7275c98423d0e25">findEdge</a> (<a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">from</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">to</a>)</td></tr>
<tr class="memdesc:af845794f83083fb6b7275c98423d0e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function has the purpose to find a edge between two nodes. If it doesn't find, it will return nullptr. It has a temporal complexity of O(E).  <br /></td></tr>
<tr class="separator:af845794f83083fb6b7275c98423d0e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fe2cd43987ad142dd8c157fe8c41b5" id="r_aa4fe2cd43987ad142dd8c157fe8c41b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_menu.html#aa4fe2cd43987ad142dd8c157fe8c41b5">greedyTSP</a> (<a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; g, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">origin</a>)</td></tr>
<tr class="memdesc:aa4fe2cd43987ad142dd8c157fe8c41b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a possible implementation for the exercise <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">4.4</a>. This method will start by the chosen origin node. It will choose the best edges by measuring the ratio between the weight and the indegree. It has a temporal complexity of O(V^2).  <br /></td></tr>
<tr class="separator:aa4fe2cd43987ad142dd8c157fe8c41b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries. It shows available functionalities, their corresponding outputs and performance in a clear, organized, and logical manner, facilitating seamless program utilization and straightforward result interpretation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad466dd83355124a6ed958430450bfe94" name="ad466dd83355124a6ed958430450bfe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad466dd83355124a6ed958430450bfe94">&#9670;&#160;</a></span>Menu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Menu::Menu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li>Default <a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> constructor - creates a <a class="el" href="class_data.html" title="This class is used to store all the contents from the .csv files into a graph. It will be used by the...">Data</a> object and parse the csv files </li>
</ul>
</p>

</div>
</div>
<a id="ab6c24dec94e1165caad13b2bb687b2ad" name="ab6c24dec94e1165caad13b2bb687b2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c24dec94e1165caad13b2bb687b2ad">&#9670;&#160;</a></span>Menu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Menu::Menu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">string</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li><a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> constructor - creates a <a class="el" href="class_data.html" title="This class is used to store all the contents from the .csv files into a graph. It will be used by the...">Data</a> object and parse the csv files, based on their path and number of nodes of each graph(size) </li>
</ul>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>of each csv file to parse </td></tr>
    <tr><td class="paramname">size</td><td>number o nodes of each graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c6b49afcdd05110a3516efadba215f8" name="a7c6b49afcdd05110a3516efadba215f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6b49afcdd05110a3516efadba215f8">&#9670;&#160;</a></span>CalculateTotalCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::CalculateTotalCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>hamiltonianCircuit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to calculate the cost of the path from the Hamiltonian Circuit. It has the complexity of O(V). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hamiltonianCircuit</td><td>Vector with the Hamiltonian Circuit. </td></tr>
    <tr><td class="paramname">c</td><td>Unordered_map with the coordinates of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>It returns the cost of the whole path. </dd></dl>

</div>
</div>
<a id="aa1fa547b6b61e524bdc16b546ac66d80" name="aa1fa547b6b61e524bdc16b546ac66d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fa547b6b61e524bdc16b546ac66d80">&#9670;&#160;</a></span>christofides_tsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::christofides_tsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function approximates the solution to the Traveling Salesman Problem (TSP) using Christofides' algorithm and improves the solution with a 2-opt optimization. It has the temporal complexity of O(V^3). </p>
<p>Christofides' algorithm is a well-known approximation algorithm for the TSP that guarantees a tour length within <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">1.5</a> times the optimal solution. The algorithm consists of the following steps:</p><ol type="1">
<li>Compute a Minimum Spanning Tree (MST) of the graph.</li>
<li>Find a minimum weight perfect matching for the vertices with odd degree in the MST.</li>
<li>Combine the edges of the MST and the perfect matching to form an Eulerian graph.</li>
<li>Find an Eulerian tour in the Eulerian graph.</li>
<li>Convert the Eulerian tour to a Hamiltonian circuit by shortcutting repeated vertices.</li>
<li>Apply 2-opt optimization to the Hamiltonian circuit to further improve the tour by swapping pairs of edges to reduce the tour length. If direct distances between vertices are not available, the function uses the Haversine formula to compute distances based on geographical coordinates.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph that contain all the information about the problem in question </td></tr>
    <tr><td class="paramname">c</td><td>Unordered_map with the coordinates of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum cost of the tour started at a specific node(origin node). </dd></dl>

</div>
</div>
<a id="a49de2a458af573736812bcc8bdf44b4a" name="a49de2a458af573736812bcc8bdf44b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49de2a458af573736812bcc8bdf44b4a">&#9670;&#160;</a></span>ConvertToHamiltonianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; Menu::ConvertToHamiltonianCircuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ECircuit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to convert a Eularian Circuit into an Halmitonian Circuit. It has the complexity of O(V);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ECircuit</td><td>Eularian Circuit as a vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Halmitonian Circuit as a vector. </dd></dl>

</div>
</div>
<a id="ad0058589ed7a7e18a067c72f18ee615c" name="ad0058589ed7a7e18a067c72f18ee615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0058589ed7a7e18a067c72f18ee615c">&#9670;&#160;</a></span>eulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; Menu::eulerianCircuit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to construct a vector of the Eularian Circuit. It has the temporal complexity of O(VE). </p>
<dl class="section return"><dt>Returns</dt><dd>Eularian Circuit as a vector. </dd></dl>

</div>
</div>
<a id="af845794f83083fb6b7275c98423d0e25" name="af845794f83083fb6b7275c98423d0e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af845794f83083fb6b7275c98423d0e25">&#9670;&#160;</a></span>findEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * Menu::findEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to find a edge between two nodes. If it doesn't find, it will return nullptr. It has a temporal complexity of O(E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Origin node. </td></tr>
    <tr><td class="paramname">to</td><td>Destination node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_edge.html" title="For this specific project, an edge represents the distance between two locations(vertexes)">Edge</a> between the origin and the destination. </dd></dl>

</div>
</div>
<a id="a934fd6cae18c3a4c2072c90af6c7757b" name="a934fd6cae18c3a4c2072c90af6c7757b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934fd6cae18c3a4c2072c90af6c7757b">&#9670;&#160;</a></span>getCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt; Menu::getCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to get the coordinates of the nodes as an unordered_map. The temporal complexity is O(1) </p>
<dl class="section return"><dt>Returns</dt><dd>Unordered_map of the nodes' coordinates. </dd></dl>

</div>
</div>
<a id="a8ae62e1a2096d08d23da4557fef84f8c" name="a8ae62e1a2096d08d23da4557fef84f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae62e1a2096d08d23da4557fef84f8c">&#9670;&#160;</a></span>getGraphMenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; Menu::getGraphMenu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to get the <a class="el" href="class_graph.html" title="The main class, where the structure used for all the project resides.">Graph</a> object from the <a class="el" href="class_menu.html" title="Represents the user-friendly interface to Routing Algorithm for Ocean Shipping and Urban Deliveries....">Menu</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_graph.html" title="The main class, where the structure used for all the project resides.">Graph</a> object. </dd></dl>

</div>
</div>
<a id="aa4fe2cd43987ad142dd8c157fe8c41b5" name="aa4fe2cd43987ad142dd8c157fe8c41b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fe2cd43987ad142dd8c157fe8c41b5">&#9670;&#160;</a></span>greedyTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::greedyTSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a possible implementation for the exercise <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">4.4</a>. This method will start by the chosen origin node. It will choose the best edges by measuring the ratio between the weight and the indegree. It has a temporal complexity of O(V^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td><a class="el" href="class_graph.html" title="The main class, where the structure used for all the project resides.">Graph</a> to apply the algorithm. </td></tr>
    <tr><td class="paramname">origin</td><td>Starting node for the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>It will return the cost if there is a path or it will abort the program if it can't find a path. </dd></dl>

</div>
</div>
<a id="a62ffbc828e2cc72f42030f8496826075" name="a62ffbc828e2cc72f42030f8496826075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ffbc828e2cc72f42030f8496826075">&#9670;&#160;</a></span>haversine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::haversine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to calculate the distance in meters between two nodes. It has a temporal complexity of O(1);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first node. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first node. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second node. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the two nodes in meters. </dd></dl>

</div>
</div>
<a id="ae3f796863a9c1778f5382b95682e75d8" name="ae3f796863a9c1778f5382b95682e75d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f796863a9c1778f5382b95682e75d8">&#9670;&#160;</a></span>heirholzer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::heirholzer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ecircuit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an auxiliary function for the <a class="el" href="class_menu.html#ad0058589ed7a7e18a067c72f18ee615c" title="This function has the purpose to construct a vector of the Eularian Circuit. It has the temporal comp...">eulerianCircuit()</a>. It has the purpose to visit the edges which are also from the MST. It has the temporal complexity of O(VE) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Current node. </td></tr>
    <tr><td class="paramname">Ecircuit</td><td>Vector with the Eulerian Circuit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad28dd77536acbbeea5bca4c45b56099b" name="ad28dd77536acbbeea5bca4c45b56099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28dd77536acbbeea5bca4c45b56099b">&#9670;&#160;</a></span>minimumWeightPerfectMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::minimumWeightPerfectMatching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>odd_vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds a minimum weight perfect matching for a set of vertices with odd degree. It has the temporal complexity of O(V^3). The function takes a list of vertices with odd degree in the graph and finds a perfect matching where the sum of the weights of the matched edges is minimized. This is an auxiliary function of Christofides' algorithm;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">odd_vertices</td><td>A vector of pointers to vertices with odd degree in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adf46dee4b8249cafbe45f6492f189c" name="a5adf46dee4b8249cafbe45f6492f189c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf46dee4b8249cafbe45f6492f189c">&#9670;&#160;</a></span>preOrderWalk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; Menu::preOrderWalk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>MST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function has the purpose to iterate over the MST vector resulting from the Prim's algorithm. It has a temporal complexity of 0(VE). It can be compared to the DFS algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MST</td><td>Vector which has the vertexs from the Prim's algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pre-order walk as a vector. </dd></dl>

</div>
</div>
<a id="af1d6398a62d463a4e4c41f4e4601de51" name="af1d6398a62d463a4e4c41f4e4601de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d6398a62d463a4e4c41f4e4601de51">&#9670;&#160;</a></span>PreOrderWalkDFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::PreOrderWalkDFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is auxiliary for the preOrderWalk. It calls itself recursively until it visits all the possible nodes once. It has a temporal complexity of O(E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">result</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0120e13899d80994b3fcd38d8111d0ed" name="a0120e13899d80994b3fcd38d8111d0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120e13899d80994b3fcd38d8111d0ed">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::prim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prim's algorithm has the purpose to find the Minimum Cost Spanning Tree of a graph. It has a temporal complexity of O(E*log(V)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td><a class="el" href="class_graph.html" title="The main class, where the structure used for all the project resides.">Graph</a> to apply the Prim's algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52be722bbe9d869f93ac174134ee5cf8" name="a52be722bbe9d869f93ac174134ee5cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52be722bbe9d869f93ac174134ee5cf8">&#9670;&#160;</a></span>triangleApproximationTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::triangleApproximationTSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function approximates the solution to the Traveling Salesman Problem (TSP) using a triangle inequality heuristic. It has the temporal complexity of O(V^2). This algorithm constructs a Minimum Spanning Tree (MST) of the input graph and then performs a preorder traversal of the MST to create a Hamiltonian circuit. The triangle inequality ensures that the length of the approximated tour is at most twice the length of the optimal tour. If direct distances between vertices are not available, it uses the Haversine formula to compute distances based on geographical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph that contain all the information about the problem in question </td></tr>
    <tr><td class="paramname">c</td><td>Unordered_map with the coordinates of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum cost of the tour started at a specific node(origin node). </dd></dl>

</div>
</div>
<a id="a62025a00de3f3662142b70f21cdfd405" name="a62025a00de3f3662142b70f21cdfd405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62025a00de3f3662142b70f21cdfd405">&#9670;&#160;</a></span>tspBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> Menu::tspBacktracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function performs a backtracking algorithm, in order to find the minimum cost tour of a graph. The temporal complexity is O(V! * V). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph that contain all the information about the problem in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum cost of the tour started at a specific node(origin node) </dd></dl>

</div>
</div>
<a id="af7cc811b2234509ea0de5f80b86d7a78" name="af7cc811b2234509ea0de5f80b86d7a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cc811b2234509ea0de5f80b86d7a78">&#9670;&#160;</a></span>tspUtil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::tspUtil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>currentRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a>&#160;</td>
          <td class="paramname"><em>currentCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestRoute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>minCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auxiliary function to the backtracking algorithm that is responsible for most of the work by using a dfs search style approach and bounding. The temporal complexity is O(n!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>graph that contain all the information about the problem in question </td></tr>
    <tr><td class="paramname">current</td><td>is the current node that is being visited </td></tr>
    <tr><td class="paramname">currentRoute</td><td>the current route </td></tr>
    <tr><td class="paramname">currentCost</td><td>the cost of the current route </td></tr>
    <tr><td class="paramname">bestRoute</td><td>the route that will yield the overall minimum cost </td></tr>
    <tr><td class="paramname">minCost</td><td>is the cost of the route with the minimum cost </td></tr>
    <tr><td class="paramname">level</td><td>the level od depth of the backtracking tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24b53db47b8f918570f23e102d5eae57" name="a24b53db47b8f918570f23e102d5eae57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b53db47b8f918570f23e102d5eae57">&#9670;&#160;</a></span>twoOpt2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> Menu::twoOpt2 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">unordered_map</a>&lt; <a class="el" href="class_edge.html">int</a>, <a class="el" href="class_edge.html">pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the purpose of this function is to improve the tour obtained by the christofides algorithm, by performing The temporal complexity is O(N^2), where N is the number of vertices in the tour the swap of two edges a given number of tries until the there are no more improvements or the number of tries if exceeded </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>represent the initial tour obtain by the christofides algorithm that will be improved </td></tr>
    <tr><td class="paramname">c</td><td>Unordered_map with the coordinates of the nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_menu_8h_source.html">Menu.h</a></li>
<li><a class="el" href="_menu_8cpp.html">Menu.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
